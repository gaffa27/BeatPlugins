/* 


Name: Novel Word Count Summary
Copyright: mark stavar
Description: Display hierarchical world count by heading level and scene for documents in Novel Style, excluding 
Version: 1.0
Type: Tool
Compatibility: 1.999.14

<Description>
	<p>Simple HTML description for Plugin Library</p>
</Description>


*/


// Open development console
//Beat.openConsole();

let showTree =  1;

if (! showTree) {
    let html =
	"<head>\
  <link rel=\"stylesheet\" href=\"styles.css\">\
</head>\
<body>\
<h1>Novel Word Count Summary</h1>\
<table><tr><th>Scene</th><th>Words</th></tr>"
}
else {

let html =
    "<head>\
  <link rel=\"stylesheet\" href=\"styles.css\">\
</head>\
<body>\
<h1>Novel Word Count Summary</h1>\
<ul class=\"tree\">\
  <li>\
    <details open>";
}


// Function to count words, excluding inline notes, text with equal signs, and headings
function countWords(text) {
    // Remove inline notes, text with equal signs, and headings
    const cleanedText = text.replace(/\[\[.*?\]\]/g, '').replace(/^=.*$/gm, '').replace(/^#.*$/gm, '').replace(/^\..*$/gm, '');

    let words = 0;

    if (cleanedText != "") {
	// Split the cleaned text into words and count them
	words = cleanedText.trim().split(/\s+/).length;
	// Beat.log("line: \"" + cleanedText + "\" words: " + words)
    }
    else {
	words = 0
    }
    return words;
}

let totalCount = 0
let level2Count = 0;
let level1Count = 0
let count = 0;

let level1Html = "";
let level2Html = "";
let sceneHtml = "";
let bodyHtml = "";
let elements = new Array ();


const scenes = Beat.outline()

for (const scene of scenes) {

    if (scene.type == Beat.type.section) {
	
	elements.push( {"type": scene.typeAsString(), "level": scene.sectionDepth, "name": scene.string, "count": 0});
    }
    else if (scene.type == Beat.type.heading) {
	
	lines = Beat.linesForScene(scene);
	
	
	for (const line in lines) {
	    
	    count = 0
	    
	    for (const line of lines) {
		count += countWords(line.string)
	    }
	}     
	elements.push({"type": scene.typeAsString(), "level": scene.sectionDepth, "name": scene.string, "count": count});
    }
}

while (elements.length > 0) {

    const element = elements.pop();

    Beat.log (element["name"] + " : " + element["type"] + " : " + element["count"]);

    switch (element["type"]) {
    case "Heading":
	level2Count += element["count"];
	level1Count += element["count"];
	totalCount += element["count"];
	
bodyHtml = "<tr><td>" + element["name"] + "</td><td align=right>" + element["count"] + "</td></tr>" + bodyHtml;
	break;

    case "Section":

	switch (element["level"]) {
	case 2:
	    bodyHtml = "<tr><td>" + element["name"] + "</td><td align=right>" + level2Count + "</td></tr>" + bodyHtml;
	    level2Count = 0;
	    break;
	    
	case 1:
	    bodyHtml = "<tr><td>" + element["name"] + "</td><td align=right>" + level1Count + "</td></tr>" + bodyHtml;
	    level1Count = 0;
	    break;
	    
	default:
	    break;
	}
	break;

    default:
    break;
	
    }
}

if (! showTree) {
    html += "<tr><td>Total Words</td><td align=right>" + totalCount + "</tr>" ;
    html += bodyHtml + "</table></body>";
}
else {
    html += "<summary> Total Words " + totalCount + "</summary>";
    html += "</details></li></ul></body>";
}


Beat.log ("html: " + html);
return


Beat.htmlPanel(html, 500, 400,
	function (htmlData) {
	    
	    Beat.end()
	    
	}
);



